Cryptod
=======

This is a simple Cryptography library written in D.

Let's start with a practical example:

<pre>
	import cryptod.blockcipher.aes;
	import cryptod.mac.hmac;
	import cryptod.hash.sha1;
	import cryptod.kdf.pbkdf2;
	import cryptod.prng.mersennetwister;
	import std.datetime;
	
	ulong t = Clock.currTime().stdTime();
	
	//makes a seed from the current time
	uint[] seed = [(t&0xffff),(t>>1)&0xffff,(t>>2)&0xffff,(t>>3)&0xffff,(t>>4)&0xffff,
	(t>>5)&0xffff,(t>>6)&0xffff,(t>>7)&0xffff,(t>>8)&0xffff,(t>>9)&0xffff,(t>>10)&0xffff,
	(t>>11)&0xffff,(t>>12)&0xffff,(t>>13)&0xffff,(t>>14)&0xffff,(t>>15)&0xffff];
	//If I ever get around to it, I will build a much simpler seeding interface 
	//that will have optional sources of entropy
	
	//seeds a MersenneTwister
	MersenneTwister mt = new MersenneTwister(seed);
	
	//Generates a random salt (ideally this would be stored in a database after generating.
	ubyte[] salt = [(mt.getNextInt()&0xff),(mt.getNextInt())&0xff,(mt.getNextInt())&0xff,
	(mt.getNextInt())&0xff,(mt.getNextInt())&0xff,(mt.getNextInt())&0xff,
	(mt.getNextInt())&0xff,(mt.getNextInt())&0xff,(mt.getNextInt())&0xff];
	
	//This generates a 128-bit key from the password "password" using a 10,000 iteration PBKDF2 function.
	ubyte[] key = PBKDF2(&HMAC_SHA1, "password", salt, 10000, 16); 
	
	//Creates a new AES context for the generated key.
	AES aes = new AES(key);
	
	//converts a 16 byte input to a ubyte array
	ubyte[] input = cast(ubyte[])"A 16-byte input.";
	
	//Enciphers the input
	ubyte[] enciphered = aes.Cipher(input);
	
	//Deciphers the enciphered output
	ubyte[] deciphered = aes.InvCipher(enciphered);
	
	assert(input == deciphered);
</pre>

Ciphers
-------

Block Ciphers:
 * AES
 * Blowfish
 * Threefish
 * (BROKEN) DES
 
Stream Ciphers:
 * PRNG xor cipher (takes any deterministic prng as input.)
 
Planned:
 * Assymetric Crypto
 * Twofish
 * Serpent
 * Stream Ciphers
 
Hashes
------

Context Hashes:
 * SHA1
 * MD2
 * MD4
 * (BROKEN) Tiger
 
'Fast' Hashes: (these hashes are not suitable for cryptographic purposes.)
 * murmurhash3
 
Planned:
 * SHA2 Family
 * All SHA3 finalists (Skein &al)
 * More fast hashes

Pseudo Random Number Generators
-------------------------------
 * Mersenne Twister
 * BlumBlumShub (Note: the design of the algorithm is suppossed to be slow and is great for heavy-duty crypto)
 * Counter Mode Block Cipher PRNG (takes any block cipher as input.)
 
Key Derivation Functions
------------------------
 * PBKDF1 (might be broken, not sure, but that might be an obscure case of sha1)
 * PBKDF2 (might be broken, not sure, but that might be an obscure case of sha1)
 
More to come.

Benchmarks
----------

Tons of stuff is way too slow right now.
<pre>
	65536 murmurhash3_x86_32 in 307 milliseconds: 208.469 MB/s
	65536 murmurhash3_x86_128 in 296 milliseconds: 216.216 MB/s
	65536 murmurhash3_x64_128 in 297 milliseconds: 215.488 MB/s
	4096 md2 in 2002 milliseconds: 1.998 MB/s
	4096 sha1 in 348 milliseconds: 11.4943 MB/s
	16777216 ints generated by mersenne twister in 599 milliseconds: 106.845 MB/s
	256 ints generated by BlumBlumShub in 556 milliseconds: 0.0017564 MB/s
	1048576 texts blowfish encrypted in 588 milliseconds: 13.6054 MB/s
	65536 texts threefish encrypted in 1717 milliseconds: 1.16482 MB/s
	131072 texts aes128 encrypted in 973 milliseconds: 2.0555 MB/s
</pre>