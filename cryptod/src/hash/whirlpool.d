// Written in the D programming language

/*	Copyright Andrey A Popov 2012
 * 
 *	Permission is hereby granted, free of charge, to any person or organization
 *	obtaining a copy of the software and accompanying documentation covered by
 *	this license (the "Software") to use, reproduce, display, distribute,
 *	execute, and transmit the Software, and to prepare derivative works of the
 *	Software, and to permit third-parties to whom the Software is furnished to
 *	do so, all subject to the following:
 *	
 *	The copyright notices in the Software and this entire statement, including
 *	the above license grant, this restriction and the following disclaimer,
 *	must be included in all copies of the Software, in whole or in part, and
 *	all derivative works of the Software, unless such copies or derivative
 *	works are solely in the form of machine-executable object code generated by
 *	a source language processor.
 *	
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *	DEALINGS IN THE SOFTWARE.
 */


/**
 * Authors: Andrey A. Popov, andrey.anat.popov@gmail.com
 */


//BROKEN

//DO NOT USE YET

//DOES NOT WORK CORRECTLY

//PLEASE READ THIS

//DO NOT USE

//THERE ARE BUGS IN THE CODE

//I WILL TRACK YOU DOWN IF YOU TRY TO USE THIS AS IT'S NOT DONE.


module cryptod.hash.whirlpool;

import cryptod.hash.hash;

import std.array, std.format;

private string makeC()
{
	import std.conv;
	ubyte[8] C0 = [1,1,4,1,8,5,2,9];
	string ret = "static immutable ubyte[8][8] C = [";
	for(int i = 0; i < 8; i++)
	{
		ret ~= "[";
		for(int j = 0; j < 8; j++)
		{
			ret ~= text(C0[(8-i+j)%8]);
			if ( j != 7 )
				ret ~= ",";
		}
		ret ~= "]";
		if (i != 7)
			ret ~= ",\n";
	}
	ret ~= "];";
	return ret;
}

private string makecr(immutable ubyte[] S)
{
	import std.conv;
	string ret = "";
	for(uint r = 1; r <= 10; r++)
		{
		ret ~= "static immutable ubyte[8][8] c" ~text(r)~" = [\n";
		for(uint i = 0; i < 8; i++)
		{
			ret ~= "[";
			if(i == 0)
			{
				for(uint j = 0; j < 8; j++)
				{
					ret ~= text(S[8*(r-1)+j]);
					//ret ~= text(S[0]);
					if ( j != 7 )
						ret ~= ",";
				}
			} else {
				for(uint j = 0; j < 8; j++)
				{
					ret ~= "0";
					if ( j != 7 )
						ret ~= ",";
				}
			}	
			ret ~= "]";
			if (i != 7)
				ret ~= ",\n";
		}
		ret ~= "];\n";
	}	
	return ret;
}

private string makeKeySchedule()
{
	import std.conv;
	string ret = "";
	for(uint r = 1; r <= 10; r++)
	{
		ret ~= "K["~text(r)~"] = ro(K["~text(r-1)~"],c"~text(r)~"));\n";
	}
	return ret;
}

private string makeW()
{
	import std.conv;
	string ret = "return mu(";
	for(int r = 10; r > 0; r--)
	{
		ret ~= "ro(K["~text(r)~"],";
	}
	ret ~= "sigma(K[0],eta)";
	for(int r = 10; r > 0; r--)
	{
		ret ~= ")";
	}
	ret ~= ");\n";
	return ret;
	
}


class WhirlpoolContext : HashContext
{
	private:
	
	ubyte m8(ubyte a, ubyte b) //@safe pure nothrow//multiplication in GF[2]/(x^8+x^4+x^3+x^2+1) 0b00011101
	{
		ubyte p = 0;
		for(uint i = 0;i < 8 && a != 0 && b != 0; i++)
		{
			if((b&1)==1)
				p^=a;
			ubyte carry = a&0x80;
			a<<=1;
			if(carry == 0x80)
				a ^= 0x1D;
			b>>=1;
		}
		return p & 0xff;
	}
	
	ubyte[32] L;
	const uint R = 10;//Number of rounds
	static immutable ubyte[256] S = [
	0x18, 0x23, 0xc6, 0xE8, 0x87, 0xB8, 0x01, 0x4F, 0x36, 0xA6, 0xd2, 0xF5, 0x79, 0x6F, 0x91, 0x52,
	0x60, 0xBc, 0x9B, 0x8E, 0xA3, 0x0c, 0x7B, 0x35, 0x1d, 0xE0, 0xd7, 0xc2, 0x2E, 0x4B, 0xFE, 0x57,
	0x15, 0x77, 0x37, 0xE5, 0x9F, 0xF0, 0x4A, 0xdA, 0x58, 0xc9, 0x29, 0x0A, 0xB1, 0xA0, 0x6B, 0x85,
	0xBd, 0x5d, 0x10, 0xF4, 0xcB, 0x3E, 0x05, 0x67, 0xE4, 0x27, 0x41, 0x8B, 0xA7, 0x7d, 0x95, 0xd8,
	0xFB, 0xEE, 0x7c, 0x66, 0xdd, 0x17, 0x47, 0x9E, 0xcA, 0x2d, 0xBF, 0x07, 0xAd, 0x5A, 0x83, 0x33,
	0x63, 0x02, 0xAA, 0x71, 0xc8, 0x19, 0x49, 0xd9, 0xF2, 0xE3, 0x5B, 0x88, 0x9A, 0x26, 0x32, 0xB0,
	0xE9, 0x0F, 0xd5, 0x80, 0xBE, 0xcd, 0x34, 0x48, 0xFF, 0x7A, 0x90, 0x5F, 0x20, 0x68, 0x1A, 0xAE,
	0xB4, 0x54, 0x93, 0x22, 0x64, 0xF1, 0x73, 0x12, 0x40, 0x08, 0xc3, 0xEc, 0xdB, 0xA1, 0x8d, 0x3d,
	0x97, 0x00, 0xcF, 0x2B, 0x76, 0x82, 0xd6, 0x1B, 0xB5, 0xAF, 0x6A, 0x50, 0x45, 0xF3, 0x30, 0xEF,
	0x3F, 0x55, 0xA2, 0xEA, 0x65, 0xBA, 0x2F, 0xc0, 0xdE, 0x1c, 0xFd, 0x4d, 0x92, 0x75, 0x06, 0x8A,
	0xB2, 0xE6, 0x0E, 0x1F, 0x62, 0xd4, 0xA8, 0x96, 0xF9, 0xc5, 0x25, 0x59, 0x84, 0x72, 0x39, 0x4c,
	0x5E, 0x78, 0x38, 0x8c, 0xd1, 0xA5, 0xE2, 0x61, 0xB3, 0x21, 0x9c, 0x1E, 0x43, 0xc7, 0xFc, 0x04,
	0x51, 0x99, 0x6d, 0x0d, 0xFA, 0xdF, 0x7E, 0x24, 0x3B, 0xAB, 0xcE, 0x11, 0x8F, 0x4E, 0xB7, 0xEB,
	0x3c, 0x81, 0x94, 0xF7, 0xB9, 0x13, 0x2c, 0xd3, 0xE7, 0x6E, 0xc4, 0x03, 0x56, 0x44, 0x7F, 0xA9,
	0x2A, 0xBB, 0xc1, 0x53, 0xdc, 0x0B, 0x9d, 0x6c, 0x31, 0x74, 0xF6, 0x46, 0xAc, 0x89, 0x14, 0xE1,
	0x16, 0x3A, 0x69, 0x09, 0x70, 0xB6, 0xd0, 0xEd, 0xcc, 0x42, 0x98, 0xA4, 0x28, 0x5c, 0xF8, 0x86
	];
	//mixin(makeC());
	static immutable ubyte[8][8] C = [
	[1,1,4,1,8,5,2,9],
	[9,1,1,4,1,8,5,2],
	[2,9,1,1,4,1,8,5],
	[5,2,9,1,1,4,1,8],
	[8,5,2,9,1,1,4,1],
	[1,8,5,2,9,1,1,4],
	[4,1,8,5,2,9,1,1],
	[1,4,1,8,5,2,9,1]];
	mixin(makecr(S));
	ubyte[] M;
	ubyte[64] H;
	
	ubyte[8][8] gamma(ubyte[8][8] M) //@safe pure nothrow
	{
		for(uint i = 0; i < 8; i++)
			for(uint j = 0; j < 8; j++)
				M[i][j] = S[M[i][j]];
		return M;		
	}
	ubyte[8][8] mu(ubyte[64] a) //@safe pure nothrow
	{
		ubyte[8][8] A;
		for(uint i = 0; i<8; i++)
			A[i][] = a[8*i..8*(i+1)];
//		for(uint i = 0; i < 8; i++)
//			for(uint j = 0; j < 8; j++)
//				A[i][j] = a[8*i+j];
		return A;
	}
	
	ubyte[64] mu(ubyte[8][8] a) //@safe pure nothrow
	{
		ubyte[64] A;
		for(uint i = 0; i < 8; i++)
			A[8*i..8*(i+1)] = a[i][];
//		for(uint i = 0; i < 8; i++)
//			for(uint j = 0; j < 8; j++)
//				A[8*i+j] = a[i][j];
		return A;	
	}
	
	ubyte[8][8] pi(ubyte[8][8] M) //@safe pure nothrow //shift jth column by j
	{
		ubyte[8][8] M2;
		for(uint j = 0; j < 8; j++)
			for(uint i = 0; i < 8; i++)
				M2[i][j] = M[(i-j)%8][j];
		return M2;
	}
	
	ubyte[8][8] theta(ubyte[8][8] a) //@safe pure nothrow
	{
		union word { ulong l; ubyte[8] b; }
		word ll;
		ubyte[8][8] A;
		for(uint i = 0; i < 8; i++)
			for(uint j = 0; j < 8; j++)
			{
				A[i][j] =   m8(a[i][0],C[0][j]) ^ m8(a[i][1],C[1][j]) ^ m8(a[i][2],C[2][j]) ^ m8(a[i][3],C[3][j]) ^
							m8(a[i][4],C[4][j]) ^ m8(a[i][5],C[5][j]) ^ m8(a[i][6],C[6][j]) ^ m8(a[i][7],C[7][j]);
//				A[i][j] =   m8(C[i][0],a[0][j]) ^ m8(C[i][1],a[1][j]) ^ m8(C[i][2],a[2][j]) ^ m8(C[i][3],a[3][j]) ^
//							m8(C[i][4],a[4][j]) ^ m8(C[i][5],a[5][j]) ^ m8(C[i][6],a[6][j]) ^ m8(C[i][7],a[7][j]);
			}				
		
		return A;
	}
	
	ubyte[8][8] sigma(ubyte[8][8] k, ubyte[8][8] a) //@safe pure nothrow
	{
		for(uint i = 0; i < 8; i++)
			for(uint j = 0; j < 8; j++)
				a[i][j] ^= k[i][j];	
		return a;
	}
	
	ubyte[64] W(ubyte[64] Key, ubyte[8][8] eta)
	{
		ubyte[8][8][11] K = keySchedule(Key);
		return mu(ro(K[10],ro(K[9],ro(K[8],ro(K[7],ro(K[6],ro(K[5],ro(K[4],ro(K[3],ro(K[2],ro(K[1],sigma(K[0],eta))))))))))));
		//mixin(makeW());
	}
	
	ubyte[8][8] ro(ubyte[8][8] k, ubyte[8][8] a) //@safe pure nothrow
	{
		return sigma(k,theta(pi(gamma(a))));
	}
	
	ubyte[8][8][11] keySchedule(ubyte[64] Key)
	{
		ubyte[8][8][11] K;
		K[0] = mu(Key);
		K[1] = ro(K[0],c1);
		K[2] = ro(K[1],c2);
		K[3] = ro(K[2],c3);
		K[4] = ro(K[3],c4);
		K[5] = ro(K[4],c5);
		K[6] = ro(K[5],c6);
		K[7] = ro(K[6],c7);
		K[8] = ro(K[7],c8);
		K[9] = ro(K[8],c9);
		K[10] = ro(K[9],c10);
		//mixin(makeKeySchedule());
		return K;
	}
	
	void AddToHash(ubyte[] F)
	{
		import std.stdio;
		
		writeln(F.length,F);
		for(uint i = 0; i < F.length/64; i++)
		{
			ubyte[64] eta = F[i*64..64 * (i+1)];
			H[] = W(H, mu(eta))[] ^ H[] ^ eta[];
		}	
	}
	
	void PadMessage()
	{
		M ~= 0b10000000;
		while(M.length%64 != 32)
			M ~= 0;
		//Pad length	
		M ~= L;
	}
	
	void AddToLength(ulong l)
	{
		l = l*8;
		L[31] += l&0xff;
		for(int i = 31; l != 0 && i > 0 ; i--)
		{
			ubyte carry = (L[i] + l&0xff) >> 8;
			l >>= 8;
			L[i-1] += carry + l&0xff;
		}
	}
	
	public:
	this()
	{
		M = [];
		H[] = new ubyte[64];
	}
	
	void AddToContext(ubyte[] m)
	{
		//messageLength += m.length;
		AddToLength(m.length);
		ubyte[] Z = M ~ m;
		ubyte[] F = Z[0..($-($%64))];
		M = Z[$-($%64)..$];
		
		if(F.length > 0)
			AddToHash(F);
	}
	
	void AddToContext(string s)
	{
		AddToContext(cast(ubyte[])s);
	}
	
	void End()
	{
		PadMessage();
		AddToHash(M);
	}
	
	ubyte[] AsBytes()
	{
		return H;
	}
	
	string AsString()
	{
		auto writer = appender!string();
		formattedWrite(writer, "%(%02x%)",AsBytes());
		return writer.data;
	}
	
}
unittest
{
	import std.stdio;
	auto ww = new WhirlpoolContext();
	ww.AddToContext("");
	ww.End();
	writeln(ww.AsString());
	
	//writeln(makeC());
	//writeln(makecr(WhirlpoolContext.S));
	//writeln(makeKeySchedule());
	//writeln(makeW());
}

