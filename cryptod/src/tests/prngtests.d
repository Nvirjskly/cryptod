// Written in the D programming language

/*	Copyright Andrey A Popov 2012
 * 
 *	Permission is hereby granted, free of charge, to any person or organization
 *	obtaining a copy of the software and accompanying documentation covered by
 *	this license (the "Software") to use, reproduce, display, distribute,
 *	execute, and transmit the Software, and to prepare derivative works of the
 *	Software, and to permit third-parties to whom the Software is furnished to
 *	do so, all subject to the following:
 *	
 *	The copyright notices in the Software and this entire statement, including
 *	the above license grant, this restriction and the following disclaimer,
 *	must be included in all copies of the Software, in whole or in part, and
 *	all derivative works of the Software, unless such copies or derivative
 *	works are solely in the form of machine-executable object code generated by
 *	a source language processor.
 *	
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *	DEALINGS IN THE SOFTWARE.
 */

/**
 * Authors: Andrey A. Popov, andrey.anat.popov@gmail.com
 */


/*
 * These tests are designed to test whether or no a given PRNG gives a 
 * good-enough random output.
 */

module cryptod.tests.prngtest;

import cryptod.prng.prng;

import std.math;

interface Test
{
	bool run();
}

class FrequencyTest : Test //This is both the monobits test and the block test.
{
	const numTimes = 0xfffff;
	const errorMargin = 0.05f;
	uint blockSize = 4096;
	PRNG p;
	
	struct block
	{
		uint o = 0;
		uint z = 0;
	}
	
	this(PRNG p)
	{
		this.p = p;
	}
	bool run()
	{
		uint numZero = 0;
		uint numOne = 0;
		block[] M;
		uint blocks = 0;
		
		bool passed = true;
		
		for(uint i = 0; i < numTimes; i++)
		{
			if(i % blockSize == 0)
			{
				M ~= block();
				blocks++;
			}	
			uint z = p.getNextInt();
			for(uint j = 0; j < 32; j++)
			{
				if(((z >> j) & 1) == 0)
				{
					numZero++;
					M[blocks-1].z++;
				} else {
					numOne++;
					M[blocks-1].o++;
				}
				 
			}
		}
		double ratio = (cast(double)numZero)/(cast(double)numOne);
		double dif = (ratio > 1f) ? 1f - ratio : ratio - 1f;
		
		passed = passed && (dif < errorMargin);
		
		for(uint i = 0; i < blocks; i++)
		{
			ratio = (cast(double)M[i].o)/(cast(double)M[i].z);
			dif = (ratio > 1f) ? 1f - ratio : ratio - 1f;
		
			passed = passed && (dif < errorMargin);
		}
		
		return passed;
	}
}

class RunsTest : Test
{
	private:
	const numTimes = 0xffff;
	const errorMargin = 0.001f;
	PRNG p;
	
	
	/**
	 * A normal CDF aproximation algorithm due to Hart
	 */
	double normalCDF(double z)
	{
		double zabs;
		double p;
		double expntl,pdf;
	
		const double p0 = 220.2068679123761;
		const double p1 = 221.2135961699311;
		const double p2 = 112.0792914978709;
		const double p3 = 33.91286607838300;
		const double p4 = 6.373962203531650;
		const double p5 = .7003830644436881;
		const double p6 = .3526249659989109E-01;
	
		const double q0 = 440.4137358247522;
		const double q1 = 793.8265125199484;
		const double q2 = 637.3336333788311;
		const double q3 = 296.5642487796737;
		const double q4 = 86.78073220294608;
		const double q5 = 16.06417757920695;
		const double q6 = 1.755667163182642;
		const double q7 = .8838834764831844E-1;
	
		const double cutoff = 7.071;
		const double root2pi = 2.506628274631001;
	
		zabs = abs(z);
	
		if (z > 37.0) {
	
			p = 1.0;
	
			return p;
	
		}
	
		if (z < -37.0) {
	
			p = 0.0;
	
			return p;
	
		}
	
		expntl = exp(-.5f*zabs*zabs);
	
		pdf = expntl/root2pi;
	
	
		if (zabs < cutoff) {
	
			p = expntl*((((((p6*zabs + p5)*zabs + p4)*zabs + p3)*zabs +
			 p2)*zabs + p1)*zabs + p0)/(((((((q7*zabs + q6)*zabs +
			 q5)*zabs + q4)*zabs + q3)*zabs + q2)*zabs + q1)*zabs +
			 q0);
	
		} else {
	
			p = pdf/(zabs + 1.0/(zabs + 2.0/(zabs + 3.0/(zabs + 4.0/
			 (zabs + 0.65)))));
	
		}
	
		if (z < 0.0) {
	
			return p;
	
		} else {
	
			p = 1.0 - p;
	
			return p;
		}
	}
	
	
	public:
	
	this(PRNG p)
	{
		this.p = p;
	}
	
	
	
	
	bool run()
	{
		uint positiveRuns = 0;
		uint negativeRuns = 0;
		uint negVals = 0;
		uint posVals = 0;
		ushort lastRun;
		uint runs = 0;
		
		for(uint i = 0; i < numTimes; i++)
		{
			uint z = p.getNextInt();
			for(uint j = 0; j < 32; j++)
			{
				ushort run = ((z >> j) & 1);
				if(i == 0 && j == 0)
					lastRun = run;
				if(run != lastRun)
				{
					(lastRun == 0) ? negativeRuns++ : positiveRuns++;
					lastRun = run;
					runs++;
				}		
				if(run == 0)
					negVals++;
				else
					posVals++;
				
			}
		}
		
		double m = cast(double)posVals;
		double n = cast(double)negVals;
		
		double expectedValue = ((2*n*m) / (n+m)) + 1;
		double variance =  ( (2*n*m) * (2*n*m*(2*n*m-m-n)) ) / ( ( (n+m)*(n+m) ) * (n+m-1) );
		
		double Z = (runs - expectedValue) / sqrt(variance);
		
		
		//double mean = (2f*(cast(double)negativeRuns)*(cast(double)positiveRuns))/(cast(double)runs)+1f;
		
		double p = normalCDF(1f-abs(Z));
		
		return p>errorMargin;
		//return mean < errorMargin;
	}
}