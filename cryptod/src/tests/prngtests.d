// Written in the D programming language

/*	Copyright Andrey A Popov 2012
 * 
 *	Permission is hereby granted, free of charge, to any person or organization
 *	obtaining a copy of the software and accompanying documentation covered by
 *	this license (the "Software") to use, reproduce, display, distribute,
 *	execute, and transmit the Software, and to prepare derivative works of the
 *	Software, and to permit third-parties to whom the Software is furnished to
 *	do so, all subject to the following:
 *	
 *	The copyright notices in the Software and this entire statement, including
 *	the above license grant, this restriction and the following disclaimer,
 *	must be included in all copies of the Software, in whole or in part, and
 *	all derivative works of the Software, unless such copies or derivative
 *	works are solely in the form of machine-executable object code generated by
 *	a source language processor.
 *	
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *	DEALINGS IN THE SOFTWARE.
 */

/**
 * Authors: Andrey A. Popov, andrey.anat.popov@gmail.com
 */


/*
 * These tests are designed to test whether or no a given PRNG gives a 
 * good-enough random output.
 */

module cryptod.tests.prngtest;

import cryptod.prng.prng;

import std.math;

interface Test
{
	bool run();
}

class FrequencyTest : Test //This is both the monobits test and the block test.
{
	const numTimes = 0xfffff;
	const errorMargin = 0.05f;
	uint blockSize = 4096;
	PRNG p;
	
	struct block
	{
		uint o = 0;
		uint z = 0;
	}
	
	this(PRNG p)
	{
		this.p = p;
	}
	bool run()
	{
		uint numZero = 0;
		uint numOne = 0;
		block[] M;
		uint blocks = 0;
		
		bool passed = true;
		
		for(uint i = 0; i < numTimes; i++)
		{
			if(i % blockSize == 0)
			{
				M ~= block();
				blocks++;
			}	
			uint z = p.getNextInt();
			for(uint j = 0; j < 32; j++)
			{
				if(((z >> j) & 1) == 0)
				{
					numZero++;
					M[blocks-1].z++;
				} else {
					numOne++;
					M[blocks-1].o++;
				}
				 
			}
		}
		double ratio = (cast(double)numZero)/(cast(double)numOne);
		double dif = (ratio > 1f) ? 1f - ratio : ratio - 1f;
		
		passed = passed && (dif < errorMargin);
		
		for(uint i = 0; i < blocks; i++)
		{
			ratio = (cast(double)M[i].o)/(cast(double)M[i].z);
			dif = (ratio > 1f) ? 1f - ratio : ratio - 1f;
		
			passed = passed && (dif < errorMargin);
		}
		
		return passed;
	}
}

class RunsTest : Test
{
	private:
	const numTimes = 0xfffff;
	const errorMargin = 0.001f;
	PRNG p;
	
	double normalCDF(double d)
	{
		return 1;
	}
	
	public:
	
	this(PRNG p)
	{
		this.p = p;
	}
	
	
	
	
	bool run()
	{
		uint positiveRuns = 0;
		uint negativeRuns = 0;
		uint negVals = 0;
		uint posVals = 0;
		ushort lastRun;
		uint runs = 0;
		
		for(uint i = 0; i < numTimes; i++)
		{
			uint z = p.getNextInt();
			for(uint j = 0; j < 32; j++)
			{
				ushort run = ((z >> j) & 1);
				if(i == 0 && j == 0)
					lastRun = run;
				if(run != lastRun)
				{
					(lastRun == 0) ? negativeRuns++ : positiveRuns++;
					lastRun = run;
					runs++;
				}		
				if(run == 0)
					negVals++;
				else
					posVals++;
				
			}
		}
		
		double m = cast(double)posVals;
		double n = cast(double)negVals;
		
		double expectedValue = ((2*n*m) / (n+m)) + 1;
		double variance =  ( (2*n*m) * (2*n*m*(2*n*m-m-n)) ) / ( ( (n+m)*(n+m) ) * (n+m-1) );
		
		double Z = (runs - expectedValue) / sqrt(variance);
		
		
		//double mean = (2f*(cast(double)negativeRuns)*(cast(double)positiveRuns))/(cast(double)runs)+1f;
		import std.stdio;
		writeln(Z);
		
		double p = normalCDF(1-abs(Z));
		
		writeln(p);
		
		return true;
		//return mean < errorMargin;
	}
}